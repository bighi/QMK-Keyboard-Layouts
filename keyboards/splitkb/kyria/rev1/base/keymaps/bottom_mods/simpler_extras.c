#include QMK_KEYBOARD_H

enum layers {
    _MAC = 0,
    _WINDOWS,     // 1
    _ACCENT,      // 2
    _NUMBER,      // 3
    _SYMBOL,      // 4
    _ADJUST       // 5
};

static void render_logo(void) {
    static const char PROGMEM geek_logo[] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x03, 0x03, 0x07, 0x0f, 0x7f, 0xff, 0xff, 0xfe, 0xfc, 0xfc, 0xf8, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x3f, 0x3f, 0x3f, 0x3f, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x1f, 0x3f, 0x3f, 0x3f, 0x1f, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xc0, 0xc0, 0xe0, 0xf0, 0xfe, 0xff, 0x7f, 0x7f, 0x3f, 0x1f, 0x1f, 0x07, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x06, 0x0e, 0x1e, 0xfe, 0xfe, 0xfe, 0xfe, 0xfc, 0xfc, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xf0, 0xf8, 0xfc, 0xfc, 0xfe, 0xfe, 0x1e, 0x0e, 0x06, 0x06, 0x06, 0x06, 0x0e, 0x3e, 0xfe, 0xfe, 0xfe, 0xfe, 0xf2, 0xe2, 0xc2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0x0c, 0x0e, 0x0e, 0x06, 0x06, 0x0e, 0x0e, 0x3e, 0xfe, 0xfe, 0xfc, 0xfc, 0xf8, 0xf0, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x06, 0x06, 0x0e, 0xfe, 0xfe, 0xfe, 0xfe, 0xfc, 0xfc, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x07, 0x0f, 0x3f, 0xff, 0xff, 0xfe, 0xfe, 0xfc, 0xf8, 0xf0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0f, 0x3f,
        0x3f, 0x7f, 0xff, 0xff, 0xff, 0xe0, 0xc0, 0xc0, 0x80, 0x80, 0xc0, 0xc0, 0xf0, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0xc0, 0xe0, 0xf0, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x1f, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0xce, 0xff, 0xff, 0xf3, 0x71, 0x71, 0x71, 0x71, 0x71, 0x71, 0xf1, 0xf1, 0xe1, 0xe0, 0xe0, 0xc0, 0xc0, 0x80,
        0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x38, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x07, 0x07, 0x0f, 0x0f, 0x1f, 0x1e, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1f, 0x1f, 0x0f, 0x0f, 0x07, 0x07, 0x03, 0x01, 0x00
    };

    oled_write_raw_P(geek_logo, sizeof(geek_logo));
}

////////////////////////////////////////////
//// LED LIGHTS ////////////////////////////
////////////////////////////////////////////

void write_rgb_mode(void) {
    oled_write_P(PSTR("RGB: "), false);

    uint32_t mode = rgblight_get_mode();
    if (mode == RGBLIGHT_MODE_STATIC_LIGHT) {
        oled_write_ln_P(PSTR("Static"), false);
    }
    else if (mode >= RGBLIGHT_MODE_BREATHING && mode <= RGBLIGHT_MODE_BREATHING + 3) {
        oled_write_ln_P(PSTR("Breathing"), false);
    }
    else if (mode >= RGBLIGHT_MODE_RAINBOW_MOOD && mode <= RGBLIGHT_MODE_RAINBOW_MOOD + 2) {
        oled_write_ln_P(PSTR("Rainbow Mood"), false);
    }
    else if (mode >= RGBLIGHT_MODE_RAINBOW_SWIRL && mode <= RGBLIGHT_MODE_RAINBOW_SWIRL + 5) {
        oled_write_ln_P(PSTR("Rainbow Swirl"), false);
    }
    // else if (mode >= RGBLIGHT_MODE_SNAKE && mode <= RGBLIGHT_MODE_SNAKE + 5) {
    //     oled_write_ln_P(PSTR("Snake"), false);
    // }
    else if (mode >= RGBLIGHT_MODE_KNIGHT && mode <= RGBLIGHT_MODE_KNIGHT + 2) {
        oled_write_ln_P(PSTR("Knight"), false);
    }
    else if (mode == RGBLIGHT_MODE_CHRISTMAS) {
        oled_write_ln_P(PSTR("Christmas"), false);
    }
    else if (mode >= RGBLIGHT_MODE_STATIC_GRADIENT && mode <= RGBLIGHT_MODE_STATIC_GRADIENT + 9) {
        oled_write_ln_P(PSTR("Gradient"), false);
    }
    // else if (mode == RGBLIGHT_MODE_ALTERNATING) {
    //     oled_write_ln_P(PSTR("Alternating"), false);
    // }
    else if (mode >= RGBLIGHT_MODE_TWINKLE && mode <= RGBLIGHT_MODE_TWINKLE + 5) {
        oled_write_ln_P(PSTR("Twinkle"), false);
    }
    else {
        oled_write_ln_P(PSTR("Other?"), false);
    }
}

void write_layer(void) {
    // Host Keyboard Layer Status
    oled_write_P(PSTR("Layer: "), false);

    switch (get_highest_layer(layer_state)) {
    // case _FUNCTION:
    //     oled_write_ln_P(PSTR("Function"), false);
    //     break;
    case _NUMBER:
        oled_write_ln_P(PSTR("Number / Nav"), false);
        break;
    case _ADJUST:
        oled_write_ln_P(PSTR("--> ADJUST <--"), false);
        break;
    case _SYMBOL:
        oled_write_ln_P(PSTR("Symbol"), false);
        break;
    case _ACCENT:
        oled_write_ln_P(PSTR("Accent"), false);
        break;
    case _MAC:
        oled_write_ln_P(PSTR("QWERTY"), false);
        break;
    case _WINDOWS:
        oled_write_ln_P(PSTR("QWERTY"), false);
        break;
    default:
        oled_write_ln_P(PSTR("QWERTY"), false);
    }
}

uint16_t count = 0;
bool oled_task_user(void) {
    if (!is_keyboard_master()) {
        if (count == 0) {
            render_logo();
            count++;
        }
    }
    else {
        oled_clear();
        write_layer();
        write_rgb_mode();
    }

    return false;
}

////////////////////////////////////////////
//// ENCODER ///////////////////////////////
////////////////////////////////////////////

bool encoder_update_user(uint8_t index, bool clockwise) {
    // left encoder
    // if (index == 1) { //first encoder
    switch (biton16(layer_state)) {
    case _NUMBER:
    case _SYMBOL:
        if (clockwise) {
            tap_code(KC_MEDIA_FAST_FORWARD); // fast forward
        }
        else {
            tap_code(KC_MEDIA_REWIND); // rewind
        }
        break;

    /*case _FUNCTION:*/
    /*    if (clockwise) {*/
    /*        tap_code(SGUI(KC_RPRN)); // fast forward*/
    /*    }*/
    /*    else {*/
    /*        tap_code(SGUI(KC_LPRN)); // fast forward*/
    /*    }*/
    /*    break;*/

    case _ADJUST:
        if (clockwise) {
            rgblight_increase_val();
        }
        else {
            rgblight_decrease_val();
        }
        break;

    default: // base layer
        if (clockwise) {
            tap_code(KC_VOLU); // volume up
        }
        else {
            tap_code(KC_VOLD); // volume down
        }
        break;
    }
    // }

    return false;
}

////////////////////////////////////////////
//// CUSTOM KEYS ///////////////////////////
////////////////////////////////////////////


// Use tap_code() for dead keys where possible (tilde/circumflex).
// This avoids the SS_TAP stringification issue and lets the
// keycode (e.g. KC_TILD, KC_CIRCUMFLEX) be used when available on
// the current keyboard/layout. We add a small delay so dead-key
// composition has time to register before the following letter.

enum custom_keycodes {
    CCEDIL = SAFE_RANGE,
    AACUTE,
    ATILDE,
    AGRAVE,
    ACIRC,
    EACUTE,
    ECIRC,
    IACUTE,
    OACUTE,
    OCIRC,
    OTILDE,
    UACUTE,
    UUMLAUT
};

bool process_record_user(uint16_t keycode, keyrecord_t* record) {
    if (!record->event.pressed) return true;

    switch (keycode) {
    case CCEDIL:
        tap_code(KC_QUOT); wait_ms(10); tap_code(KC_C);
        return false;
    case AACUTE:
        tap_code(KC_QUOT); wait_ms(10); tap_code(KC_A);
        return false;
    case ATILDE:
        /* Send '~' via Shift+` (KC_GRAVE) then the letter */
        register_code(KC_LSFT);
        tap_code(KC_GRAVE);
        unregister_code(KC_LSFT);
        wait_ms(20);
        tap_code(KC_A);
        return false;
    case AGRAVE:
        tap_code(KC_GRV); wait_ms(10); tap_code(KC_A);
        return false;
    case ACIRC:
        /* Send '^' via Shift+6 then the letter */
        register_code(KC_LSFT);
        tap_code(KC_6);
        unregister_code(KC_LSFT);
        wait_ms(20);
        tap_code(KC_A);
        return false;
    case EACUTE:
        tap_code(KC_QUOT); wait_ms(10); tap_code(KC_E);
        return false;
    case ECIRC:
        register_code(KC_LSFT);
        tap_code(KC_6);
        unregister_code(KC_LSFT);
        wait_ms(20);
        tap_code(KC_E);
        return false;
    case IACUTE:
        tap_code(KC_QUOT); wait_ms(10); tap_code(KC_I);
        return false;
    case OACUTE:
        tap_code(KC_QUOT); wait_ms(10); tap_code(KC_O);
        return false;
    case OCIRC:
        register_code(KC_LSFT);
        tap_code(KC_6);
        unregister_code(KC_LSFT);
        wait_ms(20);
        tap_code(KC_O);
        return false;
    case OTILDE:
        register_code(KC_LSFT);
        tap_code(KC_GRAVE);
        unregister_code(KC_LSFT);
        wait_ms(20);
        tap_code(KC_O);
        return false;
    case UACUTE:
        tap_code(KC_QUOT); wait_ms(10); tap_code(KC_U);
        return false;
    case UUMLAUT:
        register_code(KC_LSFT);
        tap_code(KC_QUOT);
        unregister_code(KC_LSFT);
        wait_ms(20);
        tap_code(KC_U);
        return false;
    }
    return true;
}