
enum layers {
    _QWERTY = 0,
    _BEAKL,   // 1
    _MEDIA,   // 2
    _NAV,     // 3
    _ADJUST,  // 4
    _SYMBOL,  // 5
    _NUMBER,  // 6
    _FUNCTION // 7
};

static void render_logo(void) {
    static const char PROGMEM geek_logo[] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x03, 0x03, 0x07, 0x0f, 0x7f, 0xff, 0xff, 0xfe, 0xfc, 0xfc, 0xf8, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x3f, 0x3f, 0x3f, 0x3f, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x1f, 0x3f, 0x3f, 0x3f, 0x1f, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xc0, 0xc0, 0xe0, 0xf0, 0xfe, 0xff, 0x7f, 0x7f, 0x3f, 0x1f, 0x1f, 0x07, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x06, 0x0e, 0x1e, 0xfe, 0xfe, 0xfe, 0xfe, 0xfc, 0xfc, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xf0, 0xf8, 0xfc, 0xfc, 0xfe, 0xfe, 0x1e, 0x0e, 0x06, 0x06, 0x06, 0x06, 0x0e, 0x3e, 0xfe, 0xfe, 0xfe, 0xfe, 0xf2, 0xe2, 0xc2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0x0c, 0x0e, 0x0e, 0x06, 0x06, 0x0e, 0x0e, 0x3e, 0xfe, 0xfe, 0xfc, 0xfc, 0xf8, 0xf0, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x06, 0x06, 0x0e, 0xfe, 0xfe, 0xfe, 0xfe, 0xfc, 0xfc, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x07, 0x0f, 0x3f, 0xff, 0xff, 0xfe, 0xfe, 0xfc, 0xf8, 0xf0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0f, 0x3f,
        0x3f, 0x7f, 0xff, 0xff, 0xff, 0xe0, 0xc0, 0xc0, 0x80, 0x80, 0xc0, 0xc0, 0xf0, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0xc0, 0xe0, 0xf0, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x3f, 0x1f, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0xce, 0xff, 0xff, 0xf3, 0x71, 0x71, 0x71, 0x71, 0x71, 0x71, 0xf1, 0xf1, 0xe1, 0xe0, 0xe0, 0xc0, 0xc0, 0x80,
        0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x38, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x07, 0x07, 0x0f, 0x0f, 0x1f, 0x1e, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1f, 0x1f, 0x0f, 0x0f, 0x07, 0x07, 0x03, 0x01, 0x00
    };

    oled_write_raw_P(geek_logo, sizeof(geek_logo));
}

////////////////////////////////////////////
//// OLED //////////////////////////////////
////////////////////////////////////////////

void write_rgb_mode(void) {
    oled_write_P(PSTR("RGB: "), false);

    uint32_t mode = rgblight_get_mode();
    if (mode == RGBLIGHT_MODE_STATIC_LIGHT) {
        oled_write_ln_P(PSTR("Static"), false);
    }
    else if (mode >= RGBLIGHT_MODE_BREATHING && mode <= RGBLIGHT_MODE_BREATHING + 3) {
        oled_write_ln_P(PSTR("Breathing"), false);
    }
    else if (mode >= RGBLIGHT_MODE_RAINBOW_MOOD && mode <= RGBLIGHT_MODE_RAINBOW_MOOD + 2) {
        oled_write_ln_P(PSTR("Rainbow Mood"), false);
    }
    else if (mode >= RGBLIGHT_MODE_RAINBOW_SWIRL && mode <= RGBLIGHT_MODE_RAINBOW_SWIRL + 5) {
        oled_write_ln_P(PSTR("Rainbow Swirl"), false);
    }
    // else if (mode >= RGBLIGHT_MODE_SNAKE && mode <= RGBLIGHT_MODE_SNAKE + 5) {
    //     oled_write_ln_P(PSTR("Snake"), false);
    // }
    else if (mode >= RGBLIGHT_MODE_KNIGHT && mode <= RGBLIGHT_MODE_KNIGHT + 2) {
        oled_write_ln_P(PSTR("Knight"), false);
    }
    else if (mode == RGBLIGHT_MODE_CHRISTMAS) {
        oled_write_ln_P(PSTR("Christmas"), false);
    }
    else if (mode >= RGBLIGHT_MODE_STATIC_GRADIENT && mode <= RGBLIGHT_MODE_STATIC_GRADIENT + 9) {
        oled_write_ln_P(PSTR("Gradient"), false);
    }
    // else if (mode == RGBLIGHT_MODE_ALTERNATING) {
    //     oled_write_ln_P(PSTR("Alternating"), false);
    // }
    else if (mode >= RGBLIGHT_MODE_TWINKLE && mode <= RGBLIGHT_MODE_TWINKLE + 5) {
        oled_write_ln_P(PSTR("Twinkle"), false);
    }
    else {
        oled_write_ln_P(PSTR("Other?"), false);
    }
}

void write_layer(void) {
    // Host Keyboard Layer Status
    oled_write_P(PSTR("Layer: "), false);

    switch (get_highest_layer(layer_state)) {
    case _FUNCTION:
        oled_write_ln_P(PSTR("Function"), false);
        break;
    case _NUMBER:
        oled_write_ln_P(PSTR("Number"), false);
        break;
    case _SYMBOL:
        oled_write_ln_P(PSTR("Symbol"), false);
        break;
    case _ADJUST:
        oled_write_ln_P(PSTR("ADJUST"), false);
        break;
    case _NAV:
        oled_write_ln_P(PSTR("Nav"), false);
        break;
    case _MEDIA:
        oled_write_ln_P(PSTR("Media"), false);
        break;
    case _BEAKL:
        oled_write_ln_P(PSTR("Sturdy"), true);
        break;
    default:
        oled_write_ln_P(PSTR("Qwerty"), false);
    }
}

uint16_t count = 0;
bool oled_task_user(void) {
    if (!is_keyboard_master()) {
        if (count == 0) {
            render_logo();
            count++;
        }
    }
    else {
        oled_clear();
        write_layer();
        write_rgb_mode();
    }

    return false;
}

////////////////////////////////////////////
//// ENCODER ///////////////////////////////
////////////////////////////////////////////

bool encoder_update_user(uint8_t index, bool clockwise) {
    // left encoder
    // if (index == 1) { //first encoder
    switch (biton16(layer_state)) {
    case _MEDIA:
        if (clockwise) {
            tap_code(KC_MEDIA_FAST_FORWARD); // fast forward
        }
        else {
            tap_code(KC_MEDIA_REWIND); // rewind
        }
        break;

    case _ADJUST:
        if (clockwise) {
            rgblight_increase_val();
        }
        else {
            rgblight_decrease_val();
        }
        break;

    default: // base layer
        if (clockwise) {
            tap_code(KC_VOLU); // volume up
        }
        else {
            tap_code(KC_VOLD); // volume down
        }
        break;
    }
    // }

    return false;
}

////////////////////////////////////////////
//// TAP DANCE /////////////////////////////
////////////////////////////////////////////

// // Tap Dance declarations
// enum {
//     TD_F18_MISSIONCONTROL,
//     // TD_F17_LOCK,
// };

// // Tap Dance definitions
// tap_dance_action_t tap_dance_actions[] = {
//     // Tap once for Escape, twice for Caps Lock
//     [TD_F18_MISSIONCONTROL] = ACTION_TAP_DANCE_DOUBLE(KC_F18, TD_F18_MISSIONCONTROL),
//     // [TD_F17_LOCK] = ACTION_TAP_DANCE_DOUBLE(KC_F17, LCTL(LGUI(KC_Q))),
// };

// Simple tap dance: single tap = KC_A, double tap = KC_B
enum {
    TD_TEST = 0,
};

tap_dance_action_t tap_dance_actions[] = {
    [TD_TEST] = ACTION_TAP_DANCE_DOUBLE(KC_A, KC_B),
};


////////////////////////////////////////////
//// COMBOS ////////////////////////////////
////////////////////////////////////////////

enum custom_keycodes {
    CCEDIL = SAFE_RANGE,
};

enum combos {
    QUOTE,
    TILDE,
    CEDIL,
    CIRCUMFLEX,
    COPY,
    PASTE,
    ESC,
    CUT,
    PAREN1,
    PAREN2
};

// Macro that types Ã‡ for me
bool process_record_user(uint16_t keycode, keyrecord_t* record) {
    switch (keycode) {
    case CCEDIL:
        if (record->event.pressed) {
            // when keycode QMKBEST is pressed
            SEND_STRING(SS_TAP(X_QUOT) SS_TAP(X_C));
        }
        else {
            // when keycode QMKBEST is released
        }
        break;
    }
    return true;
};

const uint16_t PROGMEM top_right[] = { KC_I, KC_U, COMBO_END };
const uint16_t PROGMEM top_left[] = { KC_R, KC_E, COMBO_END };
const uint16_t PROGMEM bottom_right[] = { KC_M, KC_COMM, COMBO_END };
const uint16_t PROGMEM bottom_left[] = { KC_C, KC_V, COMBO_END };
const uint16_t PROGMEM copy[] = { KC_R, KC_T, COMBO_END };
const uint16_t PROGMEM paste[] = { KC_V, KC_B, COMBO_END };
const uint16_t PROGMEM esc[] = { KC_Y, KC_U, COMBO_END };
const uint16_t PROGMEM cut[] = { KC_N, KC_M, COMBO_END };
const uint16_t PROGMEM open_parens[] = { LSFT_T(KC_F), LGUI_T(KC_D), COMBO_END };
const uint16_t PROGMEM close_parens[] = { RSFT_T(KC_J), RGUI_T(KC_K), COMBO_END };

combo_t key_combos[] = {
    [QUOTE] = COMBO(top_right, KC_DOUBLE_QUOTE),
    [TILDE] = COMBO(top_left, KC_TILDE),
    [CEDIL] = COMBO(bottom_right, CCEDIL),
    [CIRCUMFLEX] = COMBO(bottom_left, KC_CIRCUMFLEX),
    [COPY] = COMBO(copy, LGUI(KC_C)),
    [PASTE] = COMBO(paste, LGUI(KC_V)),
    [ESC] = COMBO(esc, KC_ESC),
    [CUT] = COMBO(cut, LGUI(KC_X)),
    [PAREN1] = COMBO(open_parens, KC_LPRN),
    [PAREN2] = COMBO(close_parens, KC_RPRN)
};
